//TaskHandle_t xTask1Handle;
//TaskHandle_t xTask2Handle;
//QueueHandle_t xQueue;
//SemaphoreHandle_t xSemaphore;
//char string[10];
//static int i = 0;
//void vTask1(void *pvParameters){
//    int State = 0;
//    char led[3][10] = {
//                       "ledon",
//                       "ledoff",
//                       "ledtoggle"
//    };
//    while(1){
//        if(xSemaphoreTake(xSemaphore,portMAX_DELAY)==pdPASS){
//            if(memcmp(led[0],string,5)==0){
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);
//                State = 1;
//            }else if(memcmp(led[1],string,6)==0){
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);
//                State = 0;
//            }else if((memcmp(led[2],string,9)==0)&&(State==1)){
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);
//                SysCtlDelay(SysCtlClockGet()/3);
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);
//                UARTprintf("TOGGLE");
//            }
//            else if((memcmp(led[2],string,9)==0)&&(State==0)){
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);
//                SysCtlDelay(SysCtlClockGet()/3);
//                GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);
//                UARTprintf("TOGGLE");
//            }
//            UARTprintf("%s\n",string);
//        }
//    }
//}
//void vTask2(void *pvParameters){
//    unsigned char ucReceivedValue;
//    portBASE_TYPE xStatus;
//    while(1){
//        if(i==10){
//            i = 0;
//        }
//        xStatus = xQueueReceive(xQueue,&ucReceivedValue,portMAX_DELAY);
//        if(xStatus == pdPASS){
//            string[i] = ucReceivedValue;
//            i = i + 1;
//            //UARTprintf("%c",ucReceivedValue);
//        }
//    }
//}
//
//void UART0IntHandler(){
//    UBaseType_t xStatus;
//    xStatus = UARTIntStatus(UART0_BASE, true);
//    UARTIntClear(UART0_BASE, xStatus);
//    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
//    unsigned char received_character;
//    while(UARTCharsAvail(UART0_BASE)){
//        received_character = UARTCharGet(UART0_BASE);
//        UARTCharPutNonBlocking(UART0_BASE, received_character); //echo character
//        if(received_character == 13){
//            i = 0;
//            UARTprintf("\n\r");
//            xSemaphoreGiveFromISR(xSemaphore,&xHigherPriorityTaskWoken);
//            portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
//        }else{
//            xQueueSendFromISR(xQueue,&received_character,&xHigherPriorityTaskWoken);
//        }
//    }
//}
//int main(){
//    SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);
//    Uart_Init();
//    PortF_Init();
//    xTaskCreate(vTask1,"Task 1",1000,(void *)0,2,&xTask1Handle);
//    xTaskCreate(vTask2,"Task 2",1000,(void *)0,1,&xTask2Handle);
//    xQueue = xQueueCreate(8,sizeof(char));
//    xSemaphore = xSemaphoreCreateBinary();
//    IntMasterEnable();
//    //UARTprintf("%d",xPortGetFreeHeapSize());
//    vTaskStartScheduler();
//    while(1){
//
//    }
//}
